\documentclass[a4paper,12pt]{book}

\setlength{\headheight}{1.1\baselineskip}
 
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

\usepackage{geometry}
\usepackage[sc]{mathpazo}

\usepackage{amsmath}

\usepackage[usenames,dvipsnames]{color} 
\usepackage{hyperref}
\usepackage{alltt}

% Para footer con páginas
\usepackage{scrpage2}
\usepackage{lastpage}

% Para insertar imágenes y ubicarlas
\usepackage{graphicx}
\usepackage{placeins}

% Para insertar código
\usepackage{xcolor}
\usepackage{listings}
\input{macros}  

\ifoot[]{}
\cfoot{\thepage\ of \pageref{LastPage} }
\ofoot[]

\pagestyle{scrplain}

\vspace{0.1in}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\begin{document}

\chapter{Colecciones}
Las colecciones son un concepto importante y poderoso al diseñar con objetos. En este capítulo veremos cómo
se modela el conocimiento de un conjunto de referencias de un objeto y su utilización para resolver un problema
concreto.
\\
\\
Agradezco a Victoria Pocladova, Carlos Lombardi, Leonardo Volinier y Jorge Silva por el artículo 
``Colecciones en Smalltalk'' del sitio web \\
\begin{minipage}[t]{0.5\textwidth}
     \href{http://pdep.com.ar/material/apuntes}{{\color{blue}http://pdep.com.ar/material/apuntes}}
\end{minipage}
\\que en conjunto con el material que he preparado convergió en
el presente apunte.
\\
 \hfill Fernando Dodino

\tableofcontents

\section{Introducción}

\subsection{¿Qué es una colección?}
La colección nos permite representar un conjunto de objetos relacionados: los jugadores de un equipo de fútbol, 
un cardumen de peces, las cosas que un héroe guarda en su mochila, un ejército, son ejemplos de este
tipo de abstracciones.\\
\\
Otra definición posible es que una colección nos sirve para modelar una relación 1 a N:\\
\begin{itemize}
\item Una factura tiene muchas líneas con productos
\item Un escritor publicó varios libros
\item Una fiesta tiene muchos invitados
\item Un héroe tiene que cumplir varias misiones
\end{itemize}

A primera vista una colección es un conjunto de objetos. Si la vemos con más precisión nos damos cuenta que es más
preciso pensarla como un conjunto de referencias: los elementos no están adentro de la colección, sino que la
colección los conoce. 
\\
\\
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{images/01_GraficoInicial_Colecciones.png}
    \caption{La colección es un conjunto de referencias a otros objetos}
\end{figure}
\\
\subsection{Representación de colecciones}
Podemos graficar la relación dinámica entre un equipo de fútbol y los jugadores que lo integran mediante un diagrama
de objetos. Este es un diagrama con características \textit{dinámicas}, porque muestra el estado 
de los objetos en un momento determinado.
\\
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{images/02_Diagrama_Objetos_Equipo.png}
    \caption{El plantel de jugadores de un equipo como una colección de objetos}
\end{figure}
\FloatBarrier
También podemos generar un diagrama de clases en UML de la misma relación:
\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.9\textwidth]{images/03_Diagrama_Clases_Equipo.png}
    \caption{El plantel de jugadores, visto al nivel de clases}
\end{figure}
\FloatBarrier
Este es un diagrama con características \textit{estáticas}, porque no depende de un caso particular
sino que muestra las relaciones entre las clases.\\
\\
¿Qué es lo que cuenta el diagrama? Que un equipo \textbf{tiene} jugadores, el conector marca una relación
de \textbf{asociación}: hay un atributo plantel en la clase Equipo (el nombre del atributo se marca en uno
de los extremos de la asociación). El asterisco (*) muestra la multiplicidad: un equipo tiene muchos jugadores.
La dirección marca qué objeto conoce a los otros: como la flecha va de Equipo a Jugador sabemos que cada equipo
tiene n jugadores, no conocemos qué características tiene la relación de Jugador a Equipo, pero se pueden dar
dos opciones:
\begin{itemize}
\item un jugador pertenece a un solo equipo, en ese caso la relación Equipo-Jugador es de \textbf{uno a muchos}
\item un jugador participa en una relación con varios equipos (por ejemplo, porque nos interesa saber
en qué equipos jugó). En ese caso la relación es de \textbf{muchos a muchos}
\end{itemize}

\section{Interfaz de una colección}
Supongamos que tenemos un álbum de fotos, otra representación posible de una colección de objetos.
¿Qué podemos hacer con esas fotografías?
\\
\begin{itemize}
\item Mirarlas, ``recorrerlas'': iterar una colección
\item Averiguar cuántas fotos hay: saber su longitud
\item Saber si está una determinada foto en el álbum: saber si un elemento pertenece a la colección
\item Pegar una foto nueva: agregar un elemento a la colección
\item Regalar una foto a alguien: eliminar un elemento de la colección
\item Buscar qué fotos son de Ushuaia: filtrar/seleccionar elementos de una colección
\item Anotar las personas que salieron en mis fotos: transformar los elementos de una colección
\item Saber si hay alguna foto de Navidad: determinar si alguno/todos los elementos satisfacen 
un criterio
\end{itemize}
En el último requerimiento aparece también la idea de conjunto vacío. 
En general podemos asociar la noción matemática de conjunto a la colección, aunque sabemos que el conjunto
matemático no tiene orden, ni se ``recorre'', mientras que en la colección eso depende de la intención que
nosotros tengamos, como veremos más adelante.
\\
\section{Un ejemplo concreto}
En ciertos casilleros el héroe puede encontrar misiones y nuevos objetivos. Por ejemplo, un mago puede
encargarle buscar un ítem mágico en una montaña lejana. Un anciano puede encargarle liberar a su hija de
los terribles trolls que habitan en la gruta de los sin nariz. Cada vez que un héroe tiene uno de estos
encuentros, él anota los datos de la misión en su diario personal. Cada vez que una misión es superada,
el héroe la marca como “cumplida”. Toda misión suma en el camino del héroe: las misiones tienen una
recompensa de oro, y de respeto.
\\
\\
¿Qué abstracciones surgen? El héroe ahora tiene una colección de misiones. En principio vamos a pensar en
dos tipos de misiones: 1) buscar un ítem mágico, 2) liberar a una doncella. Las misiones deben tener una
recompensa (más adelante podemos modelar unidades de oro o de respeto para ello), un solicitante y el estado,
que puede ser pendiente o cumplida. 
\\
\\
Además nos avisan que existen misiones difíciles, que son aquellas que tienen más de 2 meses de iniciada, 
y además
\begin{itemize}
 \item si la montaña donde está el ítem a buscar queda a más de 100 kms. o bien 
 \item si la doncella a liberar está custodiada por más de 4 trolls
\end{itemize}

\subsection{Clases a crear - versión 0}
Vamos a crear lo mínimo necesario para poder meternos de lleno en el ejemplo de las colecciones.
Ahora el héroe tendrá una colección de misiones:

\begin{lstlisting}[frame=single]
Object subclass: #Heroe
	instanceVariableNames: 'misiones ...'
\end{lstlisting}

También vamos a crear una misión posible: BuscarItemMagico, por el momento sin atributos, porque nos queremos
seguir concentrando en la interfaz y no en la implementación, es decir, qué me ofrece el objeto y no cómo lo
resuelve.

Para poder agregar una misión, vamos a definir un método explícito:

\begin{code}
#Heroe
agregarMision: unaMision
  misiones add: unaMision
\end{code}

\subsection{Iniciamos un Playground}
Abrimos un Workspace de trabajo o Playground y vamos a inicializar un juego de variables nuevo:

\begin{code}
diego := Heroe new
  agregarMision: (BuscarItemMagico new)
\end{code}

Al intentar enviar el mensaje agregarMision: recibimos el primer error, no existe la clase BuscarItemMagico,
entonces lo creamos:

\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.9\textwidth]{images/16_crear_nueva_clase.png}
    \caption{Creando una clase a demanda}
\end{figure}
\FloatBarrier

Elegimos la opción ``Define new class'' sin preocuparnos todavía por los atributos

\begin{code}
Object subclass: #BuscarItemMagico
		instanceVariableNames: '' 
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Kernel-Objects'
\end{code}

Una vez resuelta la creación de la clase, aparece un nuevo error, seleccionamos la opción Debug...

\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.7\textwidth]{images/11_error_agregarMision.png}
    \caption{La pantalla de \textit{debugging} muestra que el error ocurre al enviar el mensaje add: a misiones}
\end{figure}
\FloatBarrier

Esto se da porque la referencia a misiones quedó en nil. 

\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.9\textwidth]{images/12_error_debugging_2.png}
    \caption{misiones es una referencia a \textit{nil}, ¡falta inicializarla!}
\end{figure}
\FloatBarrier

Entonces debemos inicializar a diego cuando creemos el guerrero, esto lo podemos hacer manualmente o con la opción
Analyze \textgreater Generate initialize method

\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.9\textwidth]{images/13_generate_initialize.png}
    \caption{Generando un método initialize a través del IDE}
\end{figure}
\FloatBarrier

Comenzaremos usando un Set como colección, esto presupone que no nos importa el orden en el que almacenamos las
misiones y que no hay elementos duplicados: puede haber muchas liberaciones de doncellas, pero cada una 
representa una misión distinta. El Set es la implementación más equivalente al concepto matemático de conjunto
que presentamos anteriormente.
\\
\\
Ahora sí nuestro método nos queda

\begin{code}
#Heroe
initialize
	super initialize.
	misiones := Set new.
\end{code}


Al grabarlo volvemos al Playground y ejecutamos nuevamente el código mediante Do It

\begin{code}
diego := Heroe new
  agregarMision: (BuscarItemMagico new)
\end{code}


Vemos que el mensaje tuvo efecto inspeccionando la referencia diego: escribimos diego y luego Inspect It:

\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.9\textwidth]{images/14_coleccion_inicial.png}
    \caption{diego es un héroe y tiene una referencia en la colección misiones}
\end{figure}
\FloatBarrier


\subsection{Conocer el tamaño}
¿Cómo sabemos cuántas misiones tiene un héroe?

\begin{lstlisting}[frame=single]
#Heroe
cantidadMisiones
    ^misiones size
\end{lstlisting}
Y lo probamos, sabiendo que nos importa lo que va a devolver porque no es un método que tenga efecto, sino que
devuelve información, entonces elegimos la opción \textit{Print It}:

\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.6\textwidth]{images/15_diego_cantidadMisiones.png}
    \caption{diego tiene por el momento una sola misión}
\end{figure}
\FloatBarrier

\subsection{Saber si tiene elementos}
Queremos saber si un héroe tiene misiones...

\begin{lstlisting}[frame=single]
#Heroe
// Opcion 1
tieneMisiones
    ^misiones notEmpty
\end{lstlisting}

    
\begin{lstlisting}[frame=single]
// Opcion 2
tieneMisiones
    ^misiones size > 0
\end{lstlisting}

Ambas opciones parecen similares, de todas maneras la primera opción es más \textit{expresiva}. En la segunda
opción hay una traducción implícita: size \textgreater  0.... ah, es si tiene elementos. Es un detalle, 
pero un detalle que implica tiempo que se pierde cada vez que vaya a leer la implementación de este método.
\\
\\
Lo probamos...
\begin{lstlisting}[frame=single]
diego tieneMisiones
\end{lstlisting}

\subsection{Clases a crear - versión 1}
Creamos la clase Mision, con atributos solicitante, recompensa, fecha de inicio y fecha de cumplimiento. 
Para cada uno de ellos definiremos los accessors correspondientes, haciendo botón derecho sobre la clase
Mision > Refactoring > Inst Var Refactoring > Accessors 
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{images/10_accessors.png}
    \caption{El plantel de jugadores de un equipo como una colección de objetos}
\end{figure}

Dos subclases heredarán de Mision: 

\begin{itemize}
 \item BuscarItemMagico, necesitamos el atributo distanciaMontania
 \item LiberarDoncella, del cual necesitamos el atributo trollsSeguridad
\end{itemize}

Cambiaremos dinámicamente la superclase de BuscarItemMagico...

\begin{lstlisting}[frame=single]
Mision subclass: #BuscarItemMagico
	instanceVariableNames: 'distanciaMontania'
	classVariableNames: ''
	category: 'PDP-Book'
\end{lstlisting}

Damos ok al mensaje de advertencia y ahora tenemos a BuscarItemMagico como subclase de Mision.
\\
\\
Ahora definimos LiberarDoncella:

\begin{lstlisting}[frame=single]
Mision subclass: #LiberarDoncella
	instanceVariableNames: 'trollsSeguridad'
	classVariableNames: ''
	category: 'PDP-Book'
\end{lstlisting}

Una vez definidos los accessors, nos preguntamos: ¿qué comportamiento tiene una misión? Debe decirnos
si es difícil. Sabemos que esto depende de algo general (más de 2 meses de iniciada una misión) y se
especializa en cada subclase. Lo general... se codifica en la clase Misión:

\begin{lstlisting}[frame=single]
#Mision
esDificil
	^(self estaIniciadaHace: 60)
\end{lstlisting}

Claro, pero además debemos dejar que la misión delegue el comportamiento en cada implementación
\begin{lstlisting}[frame=single]
#Mision
esDificil
	^(self estaIniciadaHace: 60) && (self realmenteEsDificil)
\end{lstlisting}

Antes de resolver el método realmenteEsDificil, dejamos una posible implementación de estaIniciadaHace:

\begin{lstlisting}[frame=single]
#Mision
estaIniciadaHace: xDias
      ^(self estaAbierta) && ((Date new subtractDate: fechaInicio) > xDias)
      
estaAbierta
      ^fechaCumplimiento isNil       
\end{lstlisting}

Ahora sí el método realmenteEsDificil depende de este requerimiento:
\begin{itemize}
 \item si la montaña donde está el ítem a buscar queda a más de 100 kms. o bien 
 \item si la doncella a liberar está custodiada por más de 4 trolls
\end{itemize}

\begin{lstlisting}[frame=single]
#BuscarItemMagico
realmenteEsDificil      
  ^distanciaMontania > 100

#LiberarDoncella
realmenteEsDificil      
  ^trollsSeguridad > 4
\end{lstlisting}

Por motivos didácticos no vamos a explicar cómo se prueba la funcionalidad recientemente incorporada, pero
sabemos que este paso es fundamental para no tener inconvenientes con los pasos que vamos a hacer a continuación.

\subsection{Agregando nuevas misiones}
Vamos a asociar nuevas misiones a diego:

\begin{lstlisting}[frame=single]
diego := Heroe new
  agregarMision: (BuscarItemMagico new 
			distanciaMontania: 1000;
			solicitante: 'Mago de Oz';
			recompensa: 2000;
			fechaInicio: (Date newDay: 2 month: 2 year: 2004);
			yourself);
  agregarMision: (LiberarDoncella new 
			trollsSeguridad: 3;
			solicitante: 'Old man';
			recompensa: 10000;
			fechaInicio: (Date yesterday);
			yourself);
  agregarMision: (BuscarItemMagico new 
			distanciaMontania: 30;
			solicitante: 'Mago Cacarulo';
			recompensa: 500;
			fechaInicio: (Date yesterday);
			yourself);
  agregarMision: (LiberarDoncella new 
			trollsSeguridad: 7;
			solicitante: 'Old man';
			recompensa: 12000;
			fechaInicio: (Date yesterday);
			yourself).

\end{lstlisting}

\subsection{Misiones abiertas y cumplidas}
Queremos saber ahora qué misiones están abiertas.
\begin{itemize}
 \item El héroe conoce a sus misiones
 \item pero cada misión debe determinar si está abierta o no (es su \textbf{responsabilidad}). 
\end{itemize}

\begin{lstlisting}[frame=single]
#Heroe
misionesAbiertas
  ^misiones select: [ :mision | mision estaAbierta ] 
\end{lstlisting}

Redefinamos el printOn: de Misión para reflejar un poco más de información sobre el objeto:

\begin{lstlisting}[frame=single]
#Mision
printOn: aStream
   aStream nextPutAll: self descripcion;
		nextPutAll: ' pedido para ';
		nextPutAll: self solicitante.
\end{lstlisting}

Redefinimos el método descripción para cada subclase:

\begin{lstlisting}[frame=single]
#BuscarItemMagico
descripcion
  ^'Buscar item magico'

#LiberarDoncella
descripcion
  ^'Liberar doncella'
\end{lstlisting}
  
Probamos entonces las misiones abiertas:
\begin{lstlisting}[frame=single]
diego misionesAbiertas
   a Set(Liberar doncella pedido para Old man 
         Liberar doncella pedido para Old man 
         Buscar item magico pedido para Mago de Oz 
         Buscar item magico pedido para Mago Cacarulo)
\end{lstlisting}

Claro, todas las misiones están abiertas. ¿Cómo cumplimos todas las misiones?
\\
\\
Tenemos el mensaje menos simpático para enseñar, el do:

\begin{lstlisting}[frame=single]
#Heroe
cumplirMisiones
  self misionesAbiertas do: [ :mision | mision cumplir ] 
  
#Mision
cumplir
  fechaCumplimiento := Date new
\end{lstlisting}

En el Playground le pedimos a diego que cumpla todas sus misiones pendientes:

\begin{lstlisting}[frame=single]
diego cumplirMisiones
\end{lstlisting}

Y ahora veamos si efectivamente el método tuvo efecto:
\begin{lstlisting}[frame=single]
diego misionesAbiertas
      a Set()
\end{lstlisting}

\subsection{Objetos bloque y declaratividad}
¿Por qué dijimos que el método do: es el menos simpático? Porque si bien ignoramos de qué manera se recorre la
colección tenemos la posibilidad de hacer algo con cada elemento de la colección, por ejemplo
\begin{itemize}
 \item ignorar determinados elementos
 \item o transformar los elementos de la colección
 \item o utilizar variables de diferente alcance: variables internas al bloque do:, variables locales en el mismo
 método, o variables globales, como las variables de instancia, o las de clase
\end{itemize}
A lo largo del libro intentaremos pensar nuestras soluciones utilizando bloques de más alto nivel, que aumenten
la \textbf{declaratividad}, esto es no pensar tanto en el algoritmo, o cómo se resuelve, sino en lo que nosotros
queremos lograr (el qué). Para eso utilizaremos objetos \textbf{closures} que modelan bloques de código 
(los que se encierran entre corchetes) y la rica interfaz de colecciones que provee Smalltalk.

¿Cómo se modela un bloque de código? Muy fácil:
\begin{lstlisting}[frame=single]
factorialDe5 := [ 5 factorial ].
\end{lstlisting}

Esto no ejecuta el factorial de 5, sino que crea un objeto que sabe calcularlo. Para evaluarlo efectivamente, 
debemos pedírselo:
\begin{lstlisting}[frame=single]
factorialDe5 value
    120
\end{lstlisting}

También podemos crear objetos bloque donde le pasemos parámetros:
\begin{lstlisting}[frame=single]
factorial := [ :numero | numero factorial ].
\end{lstlisting}

Pero ahora ya no podemos evaluarlo con value:
\begin{lstlisting}[frame=single]
factorial value
\end{lstlisting}

Esto nos muestra el mensaje de error:

\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.9\textwidth]{images/17_error_bloque.png}
    \caption{El bloque espera un parámetro y no se lo pasamos}
\end{figure}
\FloatBarrier

Ahora si enviamos el valor, podemos calcular el factorial correspondiente:

\begin{lstlisting}[frame=single]
factorial value: 5
\end{lstlisting}

Tener un objeto bloque nos permite modelar, por ejemplo, un criterio de búsqueda ad-hoc:

\begin{lstlisting}[frame=single]
misionesConRecompensaMayorA: unValor
  | criterio |
  criterio := [ :mision | mision recompensa > unValor ].
  ^misiones select: criterio 
\end{lstlisting}

Esto nos permite probar:

\begin{lstlisting}[frame=single]
diego misionesConRecompensaMayorA: 2000
\end{lstlisting}

El criterio es un bloque que recibe un parámetro llamado mision (que es cualquier objeto que entienda el mensaje
recompensa) y devuelve un valor booleano. Lo podemos probar en un workspace:

\begin{lstlisting}[frame=single]
[ :mision | mision recompensa > 2000 ] value: (LiberarDoncella new recompensa: 5000)
\end{lstlisting}

Cuántos objetos intervienen:

\begin{itemize}
 \item un objeto bloque que espera un parámetro, y entiende el mensaje value:
 \item otro LiberarDoncella
\end{itemize}

Tener al bloque de código como abstracción me permite separar dos momentos: cuando creo al objeto y le digo lo
que tiene que hacer, y cuando efectivamente lo ejecuta (enviándole el mensaje value, value: o value:value: en
base a la cantidad de parámetros que tenga).


\subsection{Transformar los elementos}
Nos piden determinar quiénes son los solicitantes de las misiones de un héroe. Lo que sabemos es que cada
héroe tiene n misiones, y que cada misión tiene un solicitante, pero a su vez un solicitante puede pedir
varias misiones (la relación Solicitante-Misión es n a 1, o \textit{many-to-one}).
\\
\\
Entonces debemos
\begin{itemize}
 \item transformar cada misión en un solicitante
 \item y luego la lista de solicitantes debemos pasarla a un Set, para eliminar los duplicados.
\end{itemize}

Vemos la resolución:

\begin{lstlisting}[frame=single]
solicitantes
   ^(misiones collect: [ :mision | mision solicitante ]) asSet
\end{lstlisting}

Y lo probamos 
\begin{lstlisting}[frame=single]
diego solicitantes
   a Set('Mago Cacarulo' 'Old man' 'Mago de Oz')
\end{lstlisting}

\subsection{e}
* Interfaz de las colecciones siguiendo el ejemplo
  x* Conocer el tamaño
  x* Saber si tiene elementos
  x* Agregar un elemento
  ?* Sacar un elemento
  ?* Buscar un elemento
  x* Filtrar elementos que cumplan un criterio
  x* Transformar los elementos de una colección generando otra colección
  * Totalizar valores que almacenan objetos de una colección, reducir una colección a un valores
  * Operatorias con conjuntos: includes/contains, union, intersection.
  * Saber si todos/algún elemento cumple una condición
  * Bloque de código y Declaratividad
* Iteradores externos e internos
* Tipos de colecciones. Estáticas vs. dinámicas. Ordenadas y sin ordenar. Con índices.
  Colecciones estáticas (Ejemplos de cada una de ellas. Formas de agregar elementos.)
  * Array
  * String
  * Interval
  
  Colecciones dinámicas
  * Bag?
  * Set
  * List/Ordered Collection
  * SortedCollection
  * Map/Dictionary
  * Comparativa general

  
  
\end{document}
