\documentclass[a4paper,12pt]{book}

\setlength{\headheight}{1.1\baselineskip}
 
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

\usepackage{geometry}
\usepackage[sc]{mathpazo}

\usepackage{mathtools}
\usepackage{amssymb}

\usepackage[usenames,dvipsnames]{color} 
\usepackage{hyperref}
\usepackage{alltt}

% Para footer con páginas
\usepackage{scrpage2}
\usepackage{lastpage}

% Para insertar imágenes y ubicarlas
\usepackage{graphicx}
\usepackage{placeins}

% Para trabajar con tablas
\usepackage{multirow}
\usepackage[table]{xcolor}

% Para insertar código
\usepackage{xcolor}
\usepackage{listings}
\input{../common/macros}  

\ifoot[]{}
\ofoot[]

\pagestyle{scrplain}

\vspace{0.1in}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\begin{document}

\chapter{Colecciones}
por Fernando Dodino
\\
\\
Las colecciones son un concepto importante y poderoso al diseñar con objetos. En este capítulo veremos cómo
se modela el conocimiento de un conjunto de referencias de un objeto y su utilización para resolver un problema
concreto.
\\
\\

\tableofcontents

\newpage

\section{Introducción}

\subsection{¿Qué es una colección?}
La colección nos permite representar un conjunto de objetos relacionados: los jugadores de un equipo de fútbol, 
un cardumen de peces, las cosas que un héroe guarda en su mochila, un ejército, son ejemplos de este
tipo de abstracciones.\\
\\
Otra definición posible es que una colección nos sirve para modelar una relación 1 a N:
\begin{itemize}
\item Una factura tiene muchas líneas con productos
\item Un escritor publicó varios libros
\item Una fiesta tiene muchos invitados
\item Un héroe tiene que cumplir varias misiones
\end{itemize}

\vspace{\baselineskip}

A primera vista una colección es un conjunto de objetos. Si la vemos con más precisión nos damos cuenta que es más
preciso pensarla como un conjunto de referencias: los elementos no están adentro de la colección, sino que la
colección los conoce. 
\\
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{images/01_Grafico_Inicial.pdf}
    \caption{La colección es un conjunto de referencias a otros objetos}
\end{figure}
\FloatBarrier

\subsection{Representación}
Podemos graficar la relación dinámica entre un equipo de fútbol y los jugadores que lo integran mediante un diagrama
de objetos. Este es un diagrama con características \textit{dinámicas}, porque muestra el estado 
de los objetos en un momento determinado.
\\
\begin{figure}[h!]
    \centering
    \includegraphics[width=1.1\textwidth]{images/02_Equipo_Coleccion.pdf}
    \caption{El plantel de jugadores de un equipo como una colección de objetos}
\end{figure}
\FloatBarrier
También podemos generar un diagrama de clases de la misma relación:
\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.9\textwidth]{images/03_Diagrama_Clases_Equipo.pdf}
    \caption{El plantel de jugadores, visto al nivel de clases}
\end{figure}
\FloatBarrier
Este es un diagrama con características \textit{estáticas}, porque no depende de un caso particular
sino que muestra las relaciones entre las clases.\\
\\
¿Qué es lo que cuenta el diagrama? Que un equipo \textbf{tiene} jugadores, el conector marca una relación
de \textbf{asociación}: hay un atributo plantel en la clase Equipo (el nombre del atributo se marca en uno
de los extremos de la asociación). El asterisco (*) muestra la multiplicidad: un equipo tiene muchos jugadores.
La dirección marca qué objeto conoce a los otros: como la flecha va de Equipo a Jugador sabemos que cada equipo
tiene n jugadores, no conocemos qué características tiene la relación de Jugador a Equipo, pero se pueden dar
dos opciones:
\begin{itemize}
\item un jugador pertenece a un solo equipo, en ese caso la relación Equipo-Jugador es de \textbf{uno a muchos}
\item un jugador participa en una relación con varios equipos (por ejemplo, porque nos interesa saber
en qué equipos jugó). En ese caso la relación es de \textbf{muchos a muchos}
\end{itemize}

\section{Interfaz de una colección}
Supongamos que tenemos un álbum de fotos, otra representación posible de una colección de objetos.
¿Qué podemos hacer con esas fotografías?
\\
\begin{itemize}
\item Mirarlas, ``recorrerlas'': iterar una colección
\item Averiguar cuántas fotos hay: saber su longitud
\item Saber si está una determinada foto en el álbum: saber si un elemento pertenece a la colección
\item Pegar una foto nueva: agregar un elemento a la colección
\item Regalar una foto a alguien: eliminar un elemento de la colección
\item Seleccionar las fotos del viaje de 1999 a Ushuaia: filtrar elementos de una colección
\item Anotar las personas que salieron en mis fotos: transformar los elementos de una colección
\item Saber si hay alguna foto de Navidad: determinar si alguno o todos los elementos satisfacen 
un criterio
\end{itemize}
En el último requerimiento aparece también la idea de conjunto vacío. 
En general podemos asociar la noción matemática de conjunto a la colección, aunque sabemos que el conjunto
matemático no tiene orden, ni se ``recorre'', mientras que en la colección eso depende de la implementación 
que elijamos, como veremos más adelante.
\\
\section{Un ejemplo concreto: Misiones de un héroe}
En ciertos casilleros el héroe puede encontrar misiones y nuevos objetivos. Por ejemplo, un mago puede
encargarle buscar un ítem mágico en una montaña lejana. Un anciano puede encargarle liberar a su hija de
los terribles trolls que habitan en la gruta de los sin nariz. Cada vez que un héroe tiene uno de estos
encuentros, él anota los datos de la misión en su diario personal. Cada vez que una misión es superada,
el héroe la marca como “cumplida”. Toda misión suma en el camino del héroe: las misiones tienen una
recompensa de oro, y de respeto.
\\
\\
¿Qué abstracciones surgen? El héroe ahora tiene una colección de misiones. En principio vamos a pensar en
dos tipos de misiones: 1) buscar un ítem mágico, 2) liberar a una doncella. Las misiones tienen una
recompensa representada como un valor numérico (más adelante podemos modelar unidades de oro o de respeto
para ello), un solicitante y el estado, que puede ser pendiente o cumplida. 
\\
\\
Además nos avisan que existen misiones difíciles, que son aquellas que tienen más de 2 meses de iniciada, 
y además
\begin{itemize}
 \item la montaña donde está el ítem a buscar queda a más de 100 kms. o bien 
 \item la doncella a liberar está custodiada por más de 4 trolls
\end{itemize}

\subsection{Generar el atributo colección}
Vamos a crear lo mínimo necesario para poder meternos de lleno en el ejemplo de las colecciones.
Ahora el héroe tendrá una colección de misiones:

\begin{code}
Object subclass: #Heroe
	instanceVariableNames: 'misiones ...'
\end{code}
\vspace{\baselineskip}

También vamos a crear una misión posible: BuscarItemMagico, por el momento sin atributos, porque nos queremos
seguir concentrando en la interfaz y no en la implementación, es decir, qué me ofrece el objeto y no cómo lo
resuelve.
\newline
\newline
Para poder agregar una misión, vamos a definir un método explícito:

\begin{code}
#Heroe
agregarMision: unaMision
  misiones add: unaMision
\end{code}

\subsection{Primeras pruebas}
Abrimos un Workspace de trabajo o Playground y vamos a inicializar un juego de variables nuevo:

\begin{code}
diego := Heroe new
  agregarMision: (BuscarItemMagico new)
\end{code}

\vspace{\baselineskip}
Al intentar enviar el mensaje agregarMision: recibimos el primer error, no existe la clase BuscarItemMagico,
entonces lo creamos:

\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.8\textwidth]{images/16_crear_nueva_clase.png}
    \caption{Creando una clase a demanda}
\end{figure}
\FloatBarrier

Elegimos la opción ``Define new class'' sin preocuparnos todavía por los atributos

\begin{code}
Object subclass: #BuscarItemMagico
		instanceVariableNames: '' 
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Kernel-Objects'
\end{code}

\vspace{\baselineskip}
Una vez resuelta la creación de la clase, aparece un nuevo error, seleccionamos la opción Debug...

\begin{figure}[h!]
    \centering	
    \includegraphics[width=1\textwidth]{images/11_error_agregarMision.png}
    \caption{La pantalla de \textit{debugging} muestra que el error ocurre al enviar el mensaje add: a misiones}
\end{figure}
\FloatBarrier

Esto se da porque la referencia a misiones quedó en nil. 

\begin{figure}[h!]
    \centering	
    \includegraphics[width=1\textwidth]{images/12_error_debugging_2.png}
    \caption{misiones es una referencia a \textit{nil}, ¡falta inicializarla!}
\end{figure}
\FloatBarrier

Entonces debemos inicializar a diego cuando creemos el guerrero, esto lo podemos hacer manualmente o con la opción
Analyze \textgreater Generate initialize method

\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.9\textwidth]{images/13_generate_initialize.png}
    \caption{Generando un método initialize a través del IDE}
\end{figure}
\FloatBarrier

Comenzaremos usando un Set como colección, esto presupone que no nos importa el orden en el que almacenamos las
misiones y que no hay elementos duplicados: si liberamos dos veces a la misma doncella, cada una 
representa una misión distinta. El Set es la implementación más equivalente al concepto matemático de conjunto
que presentamos anteriormente.
\\
\\
Ahora sí nuestro método nos queda

\begin{code}
#Heroe
initialize
	super initialize.
	misiones := Set new.
\end{code}

\vspace{\baselineskip}
Al grabarlo volvemos al Playground y ejecutamos nuevamente el código mediante Do It

\begin{code}
diego := Heroe new
  agregarMision: (BuscarItemMagico new)
\end{code}

\vspace{\baselineskip}
Vemos que el mensaje tuvo efecto inspeccionando la referencia diego: escribimos diego y luego Inspect It:

\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.9\textwidth]{images/14_coleccion_inicial.png}
    \caption{diego es un héroe y tiene una referencia en la colección misiones}
\end{figure}
\FloatBarrier

\subsection{Variables y referencias}

Supongamos que el código anterior se hubiera escrito:

\begin{code}
misionX := BuscarItemMagico new.
diego := Heroe new
  agregarMision: misionX.
\end{code}

¿Qué diferencia tiene respecto a la versión anterior? Sólo creamos una variable más, esto implica
que el objeto BuscarItemMagico tiene una referencia más, algo que le importa al Garbage Collector,
no tanto a nosotros.

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/30_Referencias_colecciones.pdf}
    \caption{Dos referencias hacia el objeto BuscarItemMagico}
\end{figure}
\FloatBarrier

¿Y si luego hacemos?

\begin{code}
misionX := 'Hola'.
\end{code}

\vspace{\baselineskip}
La colección de misiones de diego sigue referenciando al mismo objeto original, sólo cambió la referencia
en mi workspace que yo llamo misionX.

\begin{figure}[h!]
    \centering	
    \includegraphics[width=1\textwidth]{images/31_Referencias_colecciones.pdf}
    \caption{Un cambio en la referencia de la variable no modifica la referencia de la colección}
\end{figure}
\FloatBarrier


\subsection{Conocer el tamaño de una colección}
¿Cómo sabemos cuántas misiones tiene un héroe?

\begin{code}
#Heroe
cantidadMisiones
    ^misiones size
\end{code}

Y lo probamos, sabiendo que nos importa lo que va a devolver porque no es un método que tenga efecto, sino que
devuelve información, entonces elegimos la opción \textit{Print It}:

\begin{figure}[h!]
    \centering	
    \includegraphics[width=0.5\textwidth]{images/15_diego_cantidadMisiones.png}
    \caption{diego tiene por el momento una sola misión}
\end{figure}
\FloatBarrier

\subsection{Saber si una colección tiene elementos}
Queremos saber si un héroe tiene misiones...

\begin{code}
#Heroe
// Opcion 1
tieneMisiones
    ^misiones notEmpty
\end{code}

    
\begin{code}
// Opcion 2
tieneMisiones
    ^misiones size > 0
\end{code}

Ambas opciones parecen similares, de todas maneras la primera opción es más \textit{expresiva}. En la segunda
opción hay una traducción implícita: size \textgreater  0.... ah, es si tiene elementos. Es un detalle, 
pero un detalle que implica tiempo que se pierde cada vez que se vaya a leer la implementación de este método.
\\
\\
Lo probamos...

\begin{code}
diego tieneMisiones
\end{code}

\subsection{Subclases nuevas para Misión}
Creamos la clase Mision, con atributos solicitante, recompensa, fecha de inicio y fecha de cumplimiento. 
Para cada uno de ellos definiremos los accessors correspondientes, haciendo botón derecho sobre la clase
Mision > Refactoring > Inst Var Refactoring > Accessors 


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{images/10_accessors.png}
    \caption{Generando los accessors (getters y setters) para cada propiedad de la clase Mision}
\end{figure}

\vspace{\baselineskip}
Dos subclases heredarán de Mision: 

\begin{itemize}
 \item BuscarItemMagico, que define el atributo distanciaMontania
 \item LiberarDoncella, con su atributo trollsSeguridad
\end{itemize}

Cambiaremos dinámicamente la superclase de BuscarItemMagico, reemplazando a Object por Mision...

\begin{code}
Mision subclass: #BuscarItemMagico
	instanceVariableNames: 'distanciaMontania'
	classVariableNames: ''
	category: 'PDP-Book'
\end{code}

Damos ok al mensaje de advertencia y ahora tenemos a BuscarItemMagico como subclase de Mision.
\\
\\
Ahora definimos LiberarDoncella:

\begin{code}
Mision subclass: #LiberarDoncella
	instanceVariableNames: 'trollsSeguridad'
	classVariableNames: ''
	category: 'PDP-Book'
\end{code}

\vspace{\baselineskip}
Una vez definidos los accessors, nos preguntamos: ¿qué comportamiento tiene una misión? Debe decirnos
si es difícil. Sabemos que esto depende de algo general (más de 2 meses de iniciada una misión) y se
especializa en cada subclase. Lo general... se codifica en la clase Misión:

\begin{code}
#Mision
esDificil
	^(self estaIniciadaHace: 60)
\end{code}

Claro, pero además debemos dejar que la misión delegue el comportamiento en cada implementación

\begin{code}
#Mision
esDificil
	^(self estaIniciadaHace: 60) & (self realmenteEsDificil)
\end{code}

Antes de resolver el método realmenteEsDificil, dejamos una posible implementación de estaIniciadaHace:

\begin{code}
#Mision
estaIniciadaHace: xDias
      ^(self estaAbierta) & ((Date new subtractDate: fechaInicio) > xDias)
      
estaAbierta
      ^fechaCumplimiento isNil       
\end{code}

\vspace{\baselineskip}
Ahora debemos resolver la implementación del método realmenteEsDificil, que
\begin{itemize}
 \item para la búsqueda del ítem mágico esto depende de que la montaña donde está el ítem se halle a más 
 de 100 kms.
 \item para la liberación de la doncella depende de que esté custodiada por más de 4 trolls
\end{itemize}

\begin{code}
#BuscarItemMagico
realmenteEsDificil      
  ^distanciaMontania > 100

#LiberarDoncella
realmenteEsDificil      
  ^trollsSeguridad > 4
\end{code}

Por motivos didácticos no vamos a explicar cómo se prueba la funcionalidad recientemente incorporada, pero
sabemos que este paso es fundamental para poder avanzar con los siguientes pasos.

\subsection{Nuevas misiones para el héroe}
Vamos a asociar nuevas misiones a diego:

\begin{code}
#Workspace
diego := Heroe new
  agregarMision: (BuscarItemMagico new 
			distanciaMontania: 1000;
			solicitante: 'Mago de Oz';
			recompensa: 2000;
			fechaInicio: (Date newDay: 2 month: 2 year: 2004);
			yourself);
  agregarMision: (LiberarDoncella new 
			trollsSeguridad: 3;
			solicitante: 'Old man';
			recompensa: 10000;
			fechaInicio: (Date yesterday);
			yourself);
  agregarMision: (BuscarItemMagico new 
			distanciaMontania: 30;
			solicitante: 'Mago Cacarulo';
			recompensa: 500;
			fechaInicio: (Date yesterday);
			yourself);
  agregarMision: (LiberarDoncella new 
			trollsSeguridad: 7;
			solicitante: 'Old man';
			recompensa: 12000;
			fechaInicio: (Date yesterday);
			yourself).

\end{code}

\subsection{Filtrar elementos de una colección}

Queremos saber ahora qué misiones están abiertas.

\begin{itemize}
 \item El héroe conoce a sus misiones
 \item pero cada misión debe determinar si está abierta o no (es su \textbf{responsabilidad}). 
\end{itemize}

\begin{code}
#Heroe
misionesAbiertas
  ^misiones select: [ :mision | mision estaAbierta ] 
\end{code}

\vspace{\baselineskip}
Redefinamos el printOn: de Misión para reflejar un poco más de información sobre el objeto:

\begin{code}
#Mision
printOn: aStream
   aStream nextPutAll: self descripcion;
		nextPutAll: ' para ';
		nextPutAll: self solicitante.
\end{code}

Redefinimos el método descripción para cada subclase:

\begin{code}
#BuscarItemMagico
descripcion
  ^'Buscar item magico'

#LiberarDoncella
descripcion
  ^'Liberar doncella'
\end{code}
  
\vspace{\baselineskip}
Probamos entonces el nuevo método:

\begin{code}
diego misionesAbiertas
   a Set(mision - 'Liberar doncella para Old man' 
         mision - 'Liberar doncella para Old man'
         mision - 'Buscar item magico para Mago de Oz'
         mision - 'Buscar item magico para Mago Cacarulo')
\end{code}

Claro, todas las misiones están abiertas. ¿Cómo cumplimos todas las misiones?
\\
\\
Tenemos el mensaje menos simpático para enseñar, el do:

\begin{code}
#Heroe
cumplirMisiones
  self misionesAbiertas do: [ :mision | mision cumplir ] 
  
#Mision
cumplir
  fechaCumplimiento := Date new
\end{code}

\vspace{\baselineskip}
En el Playground le pedimos a diego que cumpla todas sus misiones pendientes:

\begin{code}
diego cumplirMisiones
\end{code}

\vspace{\baselineskip}
Y ahora veamos si efectivamente el método tuvo efecto:

\begin{code}
diego misionesAbiertas
      a Set()
\end{code}

Antes de continuar es importante saber que estuvimos usando un concepto central en el uso de las colecciones...
\\

\section{Objetos bloque y declaratividad}
¿Por qué dijimos que el método do: es el menos simpático? Porque si bien ignoramos de qué manera se recorre la
colección tenemos la posibilidad de hacer algo con cada elemento de la colección, por ejemplo
\begin{itemize}
 \item ignorar determinados elementos
 \item utilizar variables de diferente alcance: variables internas al bloque do:, variables locales en el mismo
 método, o variables globales, como las variables de instancia, o las de clase
 \item de esa manera podemos generar una transformación de los elementos
 \item o bien totalizar valores
\end{itemize}
A lo largo del libro intentaremos pensar nuestras soluciones utilizando abstracciones de más alto nivel, 
que aumenten la \textbf{declaratividad}, esto es no pensar tanto en el algoritmo, o cómo se resuelve, 
sino en lo que nosotros queremos lograr (el qué). Para eso utilizaremos objetos \textbf{closures} que
modelan bloques de código  (los que se encierran entre corchetes) y la rica interfaz de colecciones que
provee Smalltalk.
\newline
\newline
¿Cómo se modela un bloque de código? Muy fácil:

\begin{code}
factorialDe5 := [ 5 factorial ].
\end{code}

\vspace{\baselineskip}
Esto no ejecuta el factorial de 5, sino que crea un objeto que sabe calcularlo. Para evaluarlo efectivamente, 
se lo debemos pedir enviando el mensaje value

\begin{code}
factorialDe5 value
    120
\end{code}

\vspace{\baselineskip}
También podemos crear objetos bloque donde le pasemos parámetros:

\begin{code}
factorial := [ :numero | numero factorial ].
\end{code}

\vspace{\baselineskip}
Pero ahora ya no podemos evaluarlo con value a secas:

\begin{code}
factorial value
\end{code}

\vspace{\baselineskip}
Esto nos muestra el mensaje de error:

\begin{figure}[h!]
    \centering	
    \includegraphics[width=1\textwidth]{images/17_error_bloque.png}
    \caption{El bloque espera un parámetro y no se lo pasamos}
\end{figure}
\FloatBarrier

\vspace{\baselineskip}
Ahora si enviamos el valor, podemos calcular el factorial correspondiente:

\begin{code}
factorial value: 5
\end{code}

\vspace{\baselineskip}
Tener un objeto bloque nos permite modelar, por ejemplo, un criterio de búsqueda ad-hoc:

\begin{code}
misionesConRecompensaMayorA: unValor
  | criterio |
  criterio := [ :mision | mision recompensa > unValor ].
  ^misiones select: criterio 
\end{code}

Y lo podemos probar de la siguiente manera:

\begin{code}
diego misionesConRecompensaMayorA: 2000
\end{code}

\vspace{\baselineskip}
El criterio es un bloque que recibe un parámetro llamado mision (que es cualquier objeto que entienda el mensaje
recompensa) y devuelve un valor booleano. Lo podemos probar en un workspace:

\begin{code}
[ :mision | mision recompensa > 2000 ] 
     value: (LiberarDoncella new recompensa: 5000)
\end{code}

\vspace{\baselineskip}
Cuántos objetos intervienen:

\begin{itemize}
 \item un objeto bloque que espera un parámetro, y entiende el mensaje value:
 \item otro LiberarDoncella
\end{itemize}

Tener al bloque de código como abstracción me permite separar dos momentos: cuando creo al objeto y le digo lo
que tiene que hacer, y cuando efectivamente lo ejecuta (enviándole el mensaje value, value: o value:value: en
base a la cantidad de parámetros que tenga). Por otra parte el mensaje select: se construye sin demasiado esfuerzo
una vez conocido al objeto bloque:

\begin{code}
#Collection
select: unCriterio
    | aux |
    aux := Set new.  // en realidad se utiliza otra tecnica
    self do: [ :elemento | 
         (unCriterio value: elemento) 
               ifTrue: [ aux add: elemento ] 
         ].
    ^aux
\end{code}

\vspace{\baselineskip}
Cualquier desarrollador que utilice select: se ve beneficiado porque evita los detalles algorítmicos del filtrado
de los elementos que cumplen una condición. Sólo nos concentramos en definir el criterio, no necesitamos crear
variables temporales, ni escribir condicionales (\textit{ifs}), por lo tanto, al utilizar una solución declarativa
hay menos posibilidades de cometer errores:

\begin{code}
misiones select: [ :mision | mision esDificil ]
\end{code}

vs.

\begin{code}
| misionesDificiles |
misionesDificiles := Set new.
misiones do: 
    [ :mision | (mision esDificil)
                        ifTrue: [ misionesDificiles add: mision ]
    ]
^misionesDificiles    
\end{code}

\vspace{\baselineskip}
En la segunda solución puedo: 1) olvidarme de instanciar una nueva colección, 2) equivocarme al hacer add:, 3) y 
además puedo escribir mal la condición. En la primera solución sólo puedo equivocarme en una cosa: la condición.
De lo demás se encarga el método select:.

\section{Operaciones con y sin efecto}

Hay un detalle que puede pasar inadvertido para el lector pero que es importante remarcar, el mensaje select:
\textbf{no tiene efecto} sobre la colección. Esto implica que la colección original no modifica sus referencias,
entonces si necesitamos obtener las misiones difíciles el select: devuelve una nueva colección con los elementos
que cumplen ese criterio...

\begin{figure}[h!]
    \centering
    \includegraphics[width=1.1\textwidth]{images/20_select_sin_efecto.pdf}
    \caption{El select: no afecta a la colección original, devuelve una nueva colección}
\end{figure}


\section{Más sobre colecciones}

\subsection{Transformar los elementos de una colección}
Nos piden determinar quiénes son los solicitantes de las misiones de un héroe. Lo que sabemos es que cada
héroe tiene n misiones, y que cada misión tiene un solicitante, pero a su vez un solicitante puede pedir
varias misiones (la relación Solicitante-Misión es n a 1, o \textit{many-to-one}).
\newline
\newline
Entonces debemos
\begin{itemize}
 \item transformar cada misión en un solicitante
 \item y luego la lista de solicitantes debemos pasarla a un Set, para eliminar los duplicados.
\end{itemize}

Vemos la resolución:

\begin{code}
#Heroe
solicitantes
   ^(misiones collect: [ :mision | mision solicitante ]) asSet
\end{code}

\vspace{\baselineskip}
Y lo probamos 

\begin{code}
diego solicitantes
   a Set('Mago Cacarulo' 'Old man' 'Mago de Oz')
\end{code}

Tampoco collect: es un método con efecto, genera una nueva colección:

\begin{figure}[h!]
    \centering
    \includegraphics[width=1.1\textwidth]{images/21_Collect_sin_efecto.pdf}
    \caption{El collect: tampoco afecta a la colección original}
\end{figure}

\subsection{Encontrar un elemento que satisfaga una condición}
Si queremos encontrar la primera misión de un héroe cuya recompensa sea mayor a 500, 
podemos utilizar el mensaje detect:

\begin{code}
#Heroe
misionConBuenaRecompensa
    ^misiones detect: [ :mision | mision recompensa > 500 ]
\end{code}


\subsection{Totalizar valores de una colección}
Surge un nuevo requerimiento: hay que conocer la recompensa que obtendremos si cumplimos todas las misiones.
Esto implica sumar la recompensa de cada misión que esté pendiente. Tenemos varias opciones:
\\
\begin{itemize}
 \item iterar la colección mediante un do:, preguntar a cada misión si se encuentra pendiente y en ese caso
 acumular en una variable la recompensa de dicha misión
 \item transformar las misiones pendientes en una colección de recompensas y sumarlas (aquí mediante do: o 
 bien enviando el mensaje sum. Para ver dónde está implementado pueden ubicarse en un workspace, escribir sum, 
 botón derecho y elegir Code search... \textgreater Implementors of it, o bien ver sus usos mediante botón derecho,
 Code search \textgreater Senders of it)
 \item y la tercera opción es sumarizar las tareas pendientes mediante el mensaje inject:into:
\end{itemize}

Implementamos la tercer variante de la siguiente manera:

\begin{code}
#Heroe
recompensaPendiente
   ^self misionesAbiertas 
         inject: 0 
         into: [ :total :mision | total + mision recompensa ]
\end{code}

\vspace{\baselineskip}
Para poder probar la solución, volvemos a inicializar la colección de misiones de diego, y luego
enviamos este mensaje, con la opción Print It, claro está:

\begin{code}
diego recompensaPendiente
  24500
\end{code}

\vspace{\baselineskip}
El método inject:into: permite reducir la colección a la expresión deseada, es un método poderoso una vez que
nos acostumbramos a su sintaxis. Lo que necesita es

\begin{itemize}
 \item un valor inicial a inyectarse 
 \item un bloque de código que acepta dos argumentos: el primero es el valor intermedio, el segundo es
 cada elemento de la colección y devuelve el nuevo valor que se construye para la iteración siguiente
 (hasta que resulta ser el resultado final del método inject:into:)
\end{itemize}

\vspace{\baselineskip}
Consideremos ahora que dado un conjunto de héroes queremos obtener un conjunto con todas sus misiones.
Nosotros tenemos n héroes, pero a su vez cada héroe tiene n misiones. Si pensamos en hacer un collect

\begin{code}
#Workspace
heroes := Set new.
heroes add: diego.
chino := Heroe new 
               nombre: 'chino';
               agregarMision: (LiberarDoncella new
                                   recompensa: 200;
                                   solicitante: 'Mago Capria';
                                   trollsSeguridad: 2;
                                   fechaInicio: Date today;
                                   yourself).
heroes add: chino.

heroes collect: [ :heroe | heroe misiones ]
     a Set(
              a Set(Liberar doncella pedido para Old man 
                    Buscar item magico pedido para Mago de Oz 
                    Buscar item magico pedido para Mago Cacarulo 
                    Liberar doncella pedido para Old man) 
              a Set(Liberar doncella pedido para Mago Capria))
\end{code}

esto nos devuelve una colección de colecciones, que no es lo que queremos... 
\newline
\newline
Pero podemos utilizar inject: into:, sabiendo que nuestro valor inicial será un Set nuevo,
y el valor intermedio se construye uniendo el conjunto intermedio con el conjunto de misiones de cada uno de
los héroes que participa de la colección:

\begin{code}
heroes inject: Set new
       into: [ :total :heroe | total union: heroe misiones ]
       
a Set(Buscar item magico pedido para Mago Cacarulo 
      Buscar item magico pedido para Mago de Oz 
      Liberar doncella pedido para Old man 
      Liberar doncella pedido para Mago Capria 
      Liberar doncella pedido para Old man)       
\end{code}

(el método union: lo veremos más adelante)

\vspace{\baselineskip}
Si queremos saber cuál es la mayor recompensa también podemos utilizar inject: into:, basta
con que el bloque de código tome el mayor valor entre la máxima recompensa hasta el momento y
la de cada misión. El valor inicial puede ser 0:

\begin{code}
#Heroe
mayorRecompensa
   ^misiones inject: 0
             into: [ :maxRecompensa :mision | maxRecompensa max: mision recompensa ] 
\end{code}

\vspace{\baselineskip}
Incluso la longitud de una colección puede calcularse con un inject: into: ...

\begin{code}
#Workspace
conjunto := Set new.
...
conjunto inject: 0
         into: [ :total :elemento | total + 1 ] 
\end{code}


\subsection{Ordenar elementos de una colección}
En lugar de devolver la mayor recompensa de las misiones de un héroe, vamos a devolver el objeto misión que
ofrezca la mayor recompensa para un héroe. Podemos hacerlo mediante un inject:into: claro está, definiendo el
método max: en Misión

\begin{code}
#Heroe
misionConMayorRecompensa
   ^misiones inject: misiones anyOne
             into: [ :misionMax :mision | misionMax max: mision ] 
             
#Mision
max: otraMision
    ^recompensa > otraMision recompensa
          ifTrue: [ self ]
          ifFalse: [ otraMision ]
\end{code}

\vspace{\baselineskip}
Pero otra opción consiste en ordenar las misiones por recompensa, y tomar el primer elemento:

\begin{code}
misionConMayorRecompensaSort
   ^(misiones asSortedCollection: 
     [ :mision1 :mision2 | mision1 recompensa > mision2 recompensa ])
     first
\end{code}

(los paréntesis son obligatorios para separar al bloque del mensaje first)

\vspace{\baselineskip}
El mensaje \textbf{asSortedCollection:} genera una nueva colección en base al criterio de ordenamiento, definido
por un bloque que dice, dado dos elementos, cuál va primero y cuál segundo. Para ordenar alfabéticamente
de menor a mayor una lista de verduras representadas como strings, escribimos en un workspace: 

\begin{code}
#('Rucula' 'Tomate' 'Lechuga' 'Apio') 
    asSortedCollection: [ :a :b | a < b ]
    
    a SortedCollection('Apio' 'Lechuga' 'Rucula' 'Tomate')
\end{code}

\vspace{\baselineskip}
Más adelante veremos el tipo de colección generada, que \textbf{no afecta} la colección original.

\section{Operatorias con conjuntos}

Como dijimos anteriormente, las colecciones son una implementación posible del concepto matemático de conjunto.
Ya hemos visto los mensajes isEmpty, notEmpty que permiten determinar si un elemento está o no en una colección.
Ahora veremos algunos ejemplos de lógica de conjuntos.

\subsection{Elemento contenido en un conjunto}

\begin{mdframed}[style=BoxFrame]
\( x \in X \)
\end{mdframed}
 
Una forma de determinar si un héroe debe cumplir la misión de un solicitante determinado puede ser:

\begin{code}
#Heroe
debeCumplirMisionPara: unSolicitante
    ^self solicitantes includes: unSolicitante
\end{code}

Entonces sabemos que

\begin{code}
diego debeCumplirMisionPara: 'Mago de Oz'
    true
\end{code}

\subsection{Saber si alguno de los elementos cumple una condición}

\begin{mdframed}[style=BoxFrame]
\( \exists x \in X, p(x) \)
\end{mdframed}

Queremos saber si hay alguna misión difícil. Esto puede hacerse de varias maneras

\begin{itemize}
 \item Iterando la colección con un do: y preguntando si la misión actual es difícil. En ese caso debemos
 cortar la secuencia y devolver true. Si almacenamos el resultado en una variable temporal...
 
\begin{code}
hayAlgunaMisionDificilConDo
    | result | 
    result := false
    misiones do: [ :mision | (mision esDificil) 
                                 ifTrue: [ result := true ]
                 ].
    ^result
\end{code}

 podemos olvidarnos
 de hacer el corte de la iteración, algo que sucede típicamente cuando nuestra solución está muy atada al algoritmo
 \item Otra opción puede ser heroe misionesDificiles notEmpty, lo que requiere generar
 un método misionesDificiles
 \item La tercera opción es la que vamos a elegir, donde sólo vamos a especificar qué condición debe cumplir alguno
 de los elementos...
\end{itemize}

Y lo resolvemos de esta manera:

\begin{code}
#Heroe
tieneAlgunaMisionDificil
      ^misiones anySatisfy: [ :mision | mision esDificil ] 
\end{code}

\vspace{\baselineskip}
Lo probamos

\begin{code}
diego tieneAlgunaMisionDificil
    false
\end{code}

\vspace{\baselineskip}
Para preguntar si todas las misiones cumplen alguna condición utilizamos el mensaje allSatisfy:

\begin{code}
diego misionesAbiertas 
    allSatisfy: [ :mision | mision recompensa > 500 ]
    false
\end{code}

\vspace{\baselineskip}

\subsection{Unión de conjuntos}

\begin{mdframed}[style=BoxFrame]
\( A \cup B \)
\end{mdframed}

Si un héroe puede tener amigos (referencias a otros héroes), y de cada amistad uno tiene una recompensa, que 
puede calcularse de una manera \textit{x}, no importa cómo, podríamos querer sumar las recompensas de las misiones
cumplidas y de las amistades en un método como

\begin{code}
#Heroe
recompensaTotal
   ^self cosasQueMeRecompensan 
            inject: 0
            into: [ :total :cosa | total + cosa recompensa ]
\end{code}

\vspace{\baselineskip}
Para ``sumar'' misiones y amigos podemos apelar a una de estas dos estrategias:

\begin{itemize}
 \item tenerlos en una variable de instancia juntos, lo cual posiblemente sería incómodo para trabajar
 por separado las misiones y los amigos
 \item tenerlos en referencias separadas (dos variables de instancia), pero generar un método que devuelva
 la resultante de la unión de ambos conjuntos
\end{itemize}

Vemos el segundo caso:

\begin{code}
#Heroe
cosasQueMeRecompensan
    ^self misionesCumplidas union: amigos
\end{code}

\subsection{Intersección de conjuntos}

\begin{mdframed}[style=BoxFrame]
\( A \cap B \)
\end{mdframed}

Algunos magos no confían en los héroes, por eso encargan la misma misión a diferentes personajes. Para determinar
si hay conflicto de intereses podemos definir este método

\begin{code}
#Heroe
misionesConConflictosDeInteresesCon: otroHeroe
     ^otroHeroe misiones intersection: self misiones
\end{code}

\vspace{\baselineskip}
Debemos crear el getter ``misiones'' para la variable misiones en Héroe. 
Ahora sí, lo probamos: generamos a nuestro nuevo héroe Ricardo, y le pasamos una misión de Diego, 
para eso enviamos el mensaje anyOne, que nos devuelve cualquier elemento de la colección:

\begin{code}
#Workspace
 misionCualquiera := diego misionesAbiertas anyOne.
 ricardo := Heroe new agregarMision: misionCualquiera.
 diego misionesConConflictosDeInteresesCon: ricardo
\end{code}

Cuando seleccionamos ``Print It'' vemos que aparece un Set con alguna de las misiones de Diego.

\subsection{Diferencia de conjuntos}

\begin{mdframed}[style=BoxFrame]
\( A \setminus B \)
\end{mdframed}

Ricardo tiene una nueva misión:

\begin{code}
#Workspace
 ricardo agregarMision: (BuscarItemMagico new 
			distanciaMontania: 800;
			solicitante: 'Mago Capria';
			recompensa: 1200;
			fechaInicio: (Date yesterday);
			yourself).
\end{code}

\vspace{\baselineskip}
¿Cómo sabemos qué misiones tiene exclusivamente ricardo y no diego?

\begin{code}
#Heroe
misionesExclusivasQueNoTiene: otroHeroe
    ^misiones difference: otroHeroe misiones
\end{code}

\vspace{\baselineskip}
Lo probamos

\begin{code}
#Workspace
ricardo misionesExclusivasQueNoTiene: diego
\end{code}

\subsection{Diferencia simétrica entre conjuntos}
En otras versiones de Smalltalk teníamos un método symmetricDifference:, en versiones recientes de Pharo
no aparece, pero podemos construirlo en base a la definición matemática 

\begin{mdframed}[style=BoxFrame]
\( A \bigtriangleup B = (A \setminus B) \cup (B \setminus A) \) 
\end{mdframed}

Podemos crear un método symmetricDifference: en Collection:

\begin{code}
#Collection
symmetricDifference: aCollection
	^ (self difference: aCollection) 
	     union: (aCollection difference: self)
\end{code}

y lo probamos

\begin{code}
#('Banana' 'Manzana' 'Pera') 
      symmetricDifference: #('Manzana' 'Kiwi' 'Melon')
      #('Pera' 'Banana' 'Kiwi' 'Melon')
\end{code}

\section{Tipos de Colecciones}
Hasta el momento hemos trabajado con el Set, lo que nos permite tener una colección

\begin{itemize}
 \item sin duplicados
 \item en donde no tenemos un orden
\end{itemize}

Es coherente que pedirle el segundo elemento del conjunto de misiones de diego resulte en error:

\begin{code}
diego misiones at: 2
  'Error: Instances of Set are not indexable'
\end{code}

\vspace{\baselineskip}
De todas maneras, en Smalltalk tenemos una gran variedad de ``sabores'' en cuanto a colecciones, en base a

\begin{itemize}
 \item si la colección admite o no duplicados
 \item si la cantidad de elementos es fija o variable
 \item si los elementos están ordenados
 \item la forma de acceder a los elementos es secuencial o por un índice
\end{itemize}

entre otras posibilidades. A continuación estudiaremos los diferentes tipos de colecciones \textbf{dinámicas}, que
suelen agregar nuevos elementos mediante el mensaje add: y eliminarlos mediante el mensaje remove:.

\subsection{Bag}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{images/40_Bag.pdf}
    \caption{En una bolsa o \textit{bag}, tenemos la referencia a n objetos con la cantidad de veces que se repite}
\end{figure}
\FloatBarrier

Representa una bolsa, o valija, donde guardamos ``cosas''. Como toda valija, las cosas están desordenadas: 
encontrar algo puede llevar tiempo. Sirve para representar un conjunto donde los elementos pueden 
repetirse. La cantidad de elementos es variable. Un ejemplo posible puede ser un carrito de compras 
de un supermercado: llevamos 7 latas de duraznos en almíbar, 2 paquetes de harina, 8 gaseosas y 1 yoghurt. 

\subsection{Set}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{images/40_Set.pdf}
    \caption{Un conjunto de elementos, sin orden ni duplicados}
\end{figure}
\FloatBarrier

Es el conjunto matemático, y respeta su definición: no hay elementos repetidos, ni orden. Pero mientras
el conjunto matemático es fijo, el Set de Smalltalk permite agregar o eliminar dinámicamente elementos. 
Un dato importante es que la forma de asegurar que los elementos no se repiten está basado en dos mensajes:
\textbf{=} (la igualdad que se puede redefinir) y \textbf{hash} (un número que se asocia a cada objeto).
\\
\\
Si queremos entender cómo funciona un Set, hagamos la siguiente prueba:

\begin{code}
#Workspace
numeros := Set new.
numeros add: 2.
numeros add: 3.
numeros add: 2.
numeros size
\end{code}

La respuesta es claramente 2, porque el add: no tiene efecto si queremos insertar un elemento existente.

\subsection{Interacción entre Set, = y hash}
Debemos entonces tener cuidado con la definición del = y el hash respecto a los elementos que insertemos.
\textit{Ejemplo}: supongamos que el héroe tiene un nombre con sus accessors, e incorporamos estos métodos

\begin{code}
#Heroe
= otroHeroe
    ^nombre = otroHeroe nombre
    
hash
    ^nombre hash
\end{code}

Es importante que cada vez que redefinamos el método = también hagamos lo propio con el método hash.
Entonces generamos nuestro Set de héroes:

\begin{code}
#Workspace
heroes := Set new.
heroes add: (Heroe new nombre: 'Hercules').
heroes add: (Heroe new nombre: 'Superman').
heroes add: (Heroe new nombre: 'Hercules').
heroes size
\end{code}

La respuesta es claramente \textbf{2}. Si borramos las definiciones de = y hash y volvemos a evaluar 
el código de arriba, la respuesta cambia a \textbf{3}. Es importante tener esto en cuenta cuando
vayamos a utilizar un Set para modelar una colección.

\subsection{Dictionary}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{images/40_Dictionary.pdf}
    \caption{El Dictionary permite acceder a los elementos por clave, en el ejemplo es un String
    pero podría tratarse de cualquier otro objeto}
\end{figure}
\FloatBarrier

Mientras que Bag y Set no tienen una forma de acceder a un cierto elemento, el Dictionary permite generar un
mapa de valores accesibles mediante una clave, lo que resulta en un conjunto de pares clave-valor. El ejemplo
típico de este tipo de colecciones es la agenda de contactos, y son muy útiles cuando necesitamos
acceso directo a los elementos. Dado que las claves no pueden repetirse, Dictionary hereda
comportamiento de Set. 
\\
\\
En lugar de utilizar el mensaje add:, agregamos los elementos mediante el mensaje at:put:, y los accedemos
mediante el mensaje at:.

\begin{code}
#Workspace
agenda := Dictionary new.
agenda at: 'diegote' put: diego.
agenda at: 'bocha' put: ricardo.
agenda at: 'diegote'
\end{code}

\vspace{\baselineskip}
Para iterar un Dictionary tenemos tres opciones

\begin{itemize}
 \item iterando sus claves => keysDo:
 \item iterando sus valores => valuesDo:
 \item iterando claves y valores a la vez, a partir de un objeto Association => \newline 
 keysAndValuesDo:
\end{itemize}

De todas maneras, si necesitamos trabajar con todos los elementos de un Dictionary preferiremos utilizar
los mensajes collect:, select:, detect:, inject:into:, etc.

\subsection{OrderedCollection}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{images/40_OrderedCollection.pdf}
    \caption{Una colección que respeta el orden de inserción de los elementos}
\end{figure}
\FloatBarrier

Es una lista que respeta el mismo orden en que se insertaron los elementos. Se representa como una lista
doblemente enlazada, la forma ``natural'' de acceder a los elementos es por índice numérico: el primero, 
el tercero, el sexto, e incluso el último. La lista es dinámica y admite elementos duplicados. 
\\
\\
Un ejemplo práctico es la fila del supermercado o de un banco, es importante respetar el orden de cada
persona en esa fila. Lo mismo pasa cuando al diseñar la interfaz de usuario mostramos opciones en una
lista o selector: si las opciones se ordenan distinto cada vez eso produce incomodidad al usuario.
\\
\\
La clase OrderedCollection define el método add: para que se comporte como un addLast:, es decir que cada
elemento se agrega último a la colección. Podemos implementar un modelo de pila si agregamos los elementos
enviando el mensaje addFirst: y los eliminamos mediante el removeFirst, como vemos en el ejemplo:

\begin{code}
pila := OrderedCollection new.
pila addFirst: 3.
pila addFirst: 'soy un string'.
pila addFirst: 5.5.
pila removeFirst.
pila
  an OrderedCollection('soy un string' 3)

pila removeFirst.
pila
  an OrderedCollection(3)
\end{code}

\subsection{SortedCollection}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{images/40_SortedCollection.pdf}
    \caption{En una colección con un criterio de ordenamiento específico, los elementos se van ubicando en ese orden
    conforme se van insertando}
\end{figure}
\FloatBarrier

Es una colección en donde los elementos están ordenados por un criterio, llamado sortBlock. Cada vez que
insertamos un elemento en la colección lo hacemos respetando el orden que debe tener, por lo que tienen
una pobre performance para actualizaciones masivas. Por eso, la estrategia suele ser tener un Set, Bag,
OrderedCollection para almacenar una lista de elementos y convertirla a SortedCollection con un criterio
determinado cuando tenemos que sacar informes de

\begin{itemize}
 \item los héroes que más misiones cumplieron
 \item los héroes ordenados alfabéticamente
 \item las misiones ordenadas por recompensa
\end{itemize}
etc. 

\vspace{\baselineskip}
Esto lo hacemos enviando el mensaje asSortedCollection:

\begin{code}
#Workspace
diego misionesAbiertas asSortedCollection: 
    [ :mision1 :mision2 | mision1 recompensa > mision2 recompensa ]
\end{code}

\vspace{\baselineskip}
El lector puede probar lo siguiente:

\begin{code}
#Workspace
liberarFiona := LiberarDoncella new recompensa: 200.
buscarAnilloMagico := BuscarItemMagico new recompensa: 500.
[ :a :b | a recompensa > b recompensa ] 
     value: liberarFiona value: buscarAnilloMagico
\end{code}

¿Qué devuelve? Un valor booleano, que es el que utiliza el método asSortedCollection: para definir el criterio
de ordenamiento de los elementos: si el bloque devuelve true el primer elemento se ordena antes que el segundo,
en caso contrario el segundo elemento se ordena antes que el primero.
\\
\\
También podemos utilizar el mensaje asSortedCollection sin parámetros que toma ``el orden natural de los 
elementos'', esto implica que los objetos deben entender el mensaje \textless= :

\begin{code}
#Workspace
#(8 4 15 23 42 16) asSortedCollection 
  a SortedCollection(4 8 15 16 23 42)
\end{code}

\vspace{\baselineskip}
Esto no funciona para héroes:

\begin{code}
#Workspace
heroes asSortedCollection
  {mensaje de error: Heroe no entiende el mensaje <=}
\end{code}

\vspace{\baselineskip}
Salvo que explícitamente definamos un método \textless= en Heroe:

\begin{code}
#Heroe
<= otroHeroe
   ^nombre <= otroHeroe nombre
\end{code}

Esto implica que ``naturalmente'' los héroes se ordenan alfabéticamente:

\begin{code}
#Workspace
heroes asSortedCollection
  {ahora aparecen ordenados}
\end{code}


\subsection{Colecciones estáticas}

No siempre es necesario trabajar con un conjunto dinámico de elementos. Dejar abierta esa posibilidad cuesta
espacio o tiempo, entonces podemos trabajar con una cantidad fija de elementos.

\vspace{\baselineskip}
El \textbf{Array}, también conocido como vector, trabaja con elementos que se acceden por índice posicional
numérico.
\newline
\newline
En general, no tiene sentido enviar el mensaje add: si la colección es estática.

\begin{code}
#Workspace
diasDeLaSemana := Array new: 7.
diasDeLaSemana add: 'DiaExtra'.   
{mensaje de error: '#add should not have been implemented in Array'}
\end{code}

\vspace{\baselineskip}
En el caso del Array, accedemos a los elementos mediante un mensaje at: y los actualizamos a partir del mensaje
at:put:

\begin{code}
#Workspace
diasDeLaSemana at: 1 put: 'Lunes'.
diasDeLaSemana at: 1
\end{code}

\vspace{\baselineskip}
Otra variante es el \textbf{String}, que es una secuencia de caracteres \textit{mutable}, se construye
mediante un literal (las comillas simples).

\begin{code}
nombre := 'Laura'.
nombre2 := nombre.
nombre at: 1 put: \$M.
nombre2
    Maura
\end{code}

\vspace{\baselineskip}
El lector interesado puede ver los mensajes match:, format:, expandMacrosWith:, capitalized, asUppercase,
asLowercase, asNumber, entre otros.

\vspace{\baselineskip}
Por último el objeto \textbf{Interval} permite modelar un rango de valores numérico.

\begin{code}
(1 to: 5) ...
\end{code}

\subsection{Conversión de colecciones}

Además del método asSortedCollection:, cualquier colección puede convertirse a otra utilizando el mensaje
de transformación correspondiente:

\begin{code}
filaDeHeroes := heroes asSortedCollection.
solicitantesDeMisiones := heroe solicitantes asSet.
jugadores asBag
\end{code}

\subsection{Jerarquía de colecciones}

\begin{figure}[h!]
    \centering
    \includegraphics[width=1.1\textwidth]{images/50_JerarquiaColecciones.pdf}
    \caption{Jerarquía de la clase Collection, en blanco las clases abstractas, en gris las concretas}
\end{figure}
\FloatBarrier

Algunas clases extras que el lector puede investigar:

\begin{itemize}
 \item \textbf{LinkedList}: una implementación de una lista simplemente enlazada.
 \item \textbf{Stack}: una implementación tradicional de una pila, con los métodos pop, push: y top.
 \item \textbf{LIFOQueue, SharedQueue}: una cola de acceso (eventualmente compartida) con métodos
 de actualización sincronizados.
 \item \textbf{ByteArray}: una especialización del Array que contiene enteros del 0 al 255.
 \item \textbf{Stream}: la representación del acceso a un conjunto de datos cuyo origen puede ser un socket, un
 archivo, etc. De esta clase abstracta heredan ReadStream, WriteStream, TextStream, entre otros.
 \item \textbf{IdentitySet, IdentityBag, IdentityDictionary}: son colecciones que basan el criterio de búsqueda
 en la identidad (==) en lugar de la igualdad (=)
 \item \textbf{KeyedTree}: representa un árbol cuyos nodos se acceden por clave.
 \item \textbf{Matrix}
 \item \textbf{WeakSet, WeakArray, WeakBag...}: son colecciones que referencian a objetos en forma ``débil'',
 esto significa que si ningún otro objeto los referencia son eliminados por el Garbage Collector.
\end{itemize}


\subsection{Resumen de mensajes}

Dejamos aquí una tabla con los principales mensajes que se pueden encontrar en la jerarquía de Collection,
igualmente recomendamos navegar la estructura en la versión de Smalltalk que esté trabajando el lector
para un análisis más exhaustivo:

\begin{center}

\begin{tabular}{|l|l|}
\hline
\cellcolor[gray]{0.8}
Categoria & \cellcolor[gray]{0.8} Mensajes \\
\hline
accessing & anyOne, size, at: (colecciones ordenadas) \\
\hline
adding & add: (colecciones dinamicas), addAll: \\
\hline
\multirow{2}{*} {converting} & asArray, asBag, asDictionary, \\
& asOrderedCollection, asSet, asSortedCollection: \\
\hline
\multirow{4}{*} {enumerating} & allSatisfy:, anySatisfy:, collect:, count:, \\
& detect:, detect:ifNone:, detect:ifFound:, \\
& difference:, do:, flattened, fold:, inject:into:, \\
& intersection:, noneSatisfy:, reduce:, reject:, union:\\
\hline
math functions & median, stdev, sum: \\
\hline
\multirow{2}{*} {removing} & remove:, remove:ifAbsent:, removeAll, \\
& removeAllSuchThat: \\ 
\hline
\multirow{2}{*} {testing} & contains:, ifEmpty:, includes:, \\
& isEmpty, notEmpty, ocurrencesOf: \\
\hline
\end{tabular}

\end{center}

\subsection{Taxonomía de las colecciones}

Aquí dejamos otra tabla en la que generamos una clasificación de las colecciones en base a las siguientes
características:

\begin{itemize}
 \item \textbf{secuenciales}: implica que hay un orden de los elementos
 \item \textbf{indexados}: se manejan con un índice entero, string o cualquier otro. Entienden el mensaje at:
 \item \textbf{se pueden ordenar}: el orden no tiene que ver con el momento en que se agregan
 sino con un criterio que se define (por nombre de menor a mayor, por recompensa de mayor a menor, etc.)
 \item \textbf{con claves}: implica que podemos acceder a un elemento a partir de alguna clave. El mensaje
 at: permite utilizar algo más que un número.
 \item \textbf{puede crecer}: de lo contrario son de tamaño fijo
 \item \textbf{acepta duplicados}: donde los elementos pueden repetirse
\end{itemize}

En la presente tabla clasificamos las colecciones más utilizadas:
\newline

\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\cellcolor[gray]{0.8}
Categoria & \cellcolor[gray]{0.8} Set & \cellcolor[gray]{0.8} Bag & \cellcolor[gray]{0.8} OrderedCol
& \cellcolor[gray]{0.8} SortedCol & \cellcolor[gray]{0.8} Dictionary
& \cellcolor[gray]{0.8} Array \\
\hline
Secuencia & & & $\surd$ & $\surd$ & & $\surd$ \\
\hline
Indice & & & $\surd$ & $\surd$ & & $\surd$ \\
\hline
Se ordenan & & & & $\surd$ & & \\
\hline
Busca por clave & & & & & $\surd$ & \\
\hline
Puede crecer & $\surd$ & $\surd$ & $\surd$ & $\surd$ & $\surd$ & \\
\hline
Con duplicados & & $\surd$ & $\surd$ & $\surd$ & (*) & $\surd$ \\
\hline
\end{tabular}
\newline\newline

(*) El Dictionary no permite duplicados en la clave, aunque sí permite que dos claves compartan el mismo objeto

\subsection{Cómo elegir el tipo de colección}

Si existen dudas a la hora de elegir una colección de elementos general, le proporcionamos al
lector un ayudamemoria que puede ser de utilidad:

\begin{itemize}
 \item Si la cantidad de elementos es fija, una pregunta importante es cuántas veces necesitamos acceder
 a los elementos en forma puntual. Si nos basta con tener un índice entero o no es crítica la cantidad
 de elementos, el \textbf{Array} nos puede servir, de lo contrario debería considerarse el \textbf{Dictionary}.
 \item A partir de aquí, asumimos que la colección es dinámica: se crean y eliminan gran cantidad de elementos.
 Si el orden no importa, la pregunta siguiente es si queremos evitar elementos duplicados: por sí nos conviene
 utilizar un \textbf{Set}, o un \textbf{Bag} en caso contrario. Si el orden importa, nos debemos preguntar cómo
 lo queremos definir: si es por el orden en que se agregan los elementos podemos elegir \textbf{OrderedCollection}
 o bien una \textbf{SortedCollection} si queremos utilizar un criterio de ordenamiento específico. 
\end{itemize}

\section{Iteradores externos e internos}

Sabemos que para recorrer una colección basta con enviar el mensaje do: 

\begin{code}
coleccion do: [ :elemento | ... ]
\end{code}

Esto se asemeja a la estructura \textit{for each} de varios lenguajes, como Python

\begin{lstlisting}[language=Python]  
for elemento in coleccion:
  sentencias
\end{lstlisting}

o Java 8 / 7
\begin{lstlisting}[language=Java]  
coleccion.forEach((elemento) ->
  elemento.mensaje());
  
for (Elemento elemento : coleccion) {
  elemento.mensaje();
}
\end{lstlisting}

Esto es lo que se conoce como un ``iterador interno''. Otra opción es separar dos abstracciones:

\begin{itemize}
 \item la que define cómo se almacenan los elementos
 \item y la forma en que se recorre la colección
\end{itemize}

esto se conoce como ``iterador externo'', y es uno de los patrones de Diseño expresados por Gamma et al.{\footnote{
Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, \textit{Design Patterns, Elements of reusable 
object-oriented software}, Addison-Wesley}
\\
\\
Esta idea está presente cuando utilizamos un Set y luego enviamos el mensaje asSortedCollection: para recorrer
la lista en un orden diferente al que están almacenados. 
\\
\\
Otro ejemplo posible de Iterador externo sería organizar una contienda entre dos héroes. La contienda comienza
con un ataque de uno de los héroes por turno y termina cuando alguno de los dos héroes queda moribundo
(un nivel de vida a determinar). Entonces podemos pensar en que la contienda necesita una abstracción que
maneje el turno de ataque de cada héroe:

\begin{itemize}
 \item el iterador necesita conocer a ambos héroes
 \item habrá siguiente turno si ninguno de los héroes queda moribundo
 \item y el turno se va alternando entre el primer y el segundo héroe
\end{itemize}

La implementación la vemos aquí:

\begin{code}
#TurnoContienda, VI: heroes indice

initialize
   indice := 0.
   heroes := OrderedCollection new.
   
hayProximoTurno
   ^heroes allSatisfy: [ :heroe | heroe estaMoribundo not ]
   
siguiente
   self hayProximoTurno 
        ifFalse: [ self error: 'La contienda ha terminado' ].
   indice := indice + 1.
   (indice > heroes size) ifTrue: [ indice := 1 ].
   ^heroes at: indice
\end{code}

\vspace{\baselineskip}
Si lo probamos en un playground veremos cómo se genera el turno de cada héroe:

\begin{code}
#Workspace
diego nombre: 'Diego'.
ricardo nombre: 'Bocha'.

turno := TurnoContienda new 
   agregarHeroe: diego;
   agregarHeroe: ricardo.

turno siguiente nombre => 'Diego'
turno siguiente nombre => 'Bocha'
turno siguiente nombre => 'Diego'
turno siguiente nombre => 'Bocha'
turno siguiente nombre => 'Diego'
\end{code}

\section{Resumen}

Hemos visto en el presente capítulo

\begin{itemize}
 \item que las colecciones son un concepto fundamental en el diseño orientado a objetos para modelar un conjunto
 de elementos que están relacionados. 
 \item que las colecciones proveen una interfaz de mensajes muy rica que incluyen métodos para
 filtrar los elementos, transformarlos en otra colección, reducir los elementos para obtener
 un valor, encontrar un elemento, o trabajar con la lógica de conjuntos
 \item esta gran cantidad de mensajes permite subir el nivel de abstracción, despegando al desarrollador de la
 parte algorítmica repetitiva, mediante el uso de los objetos bloque
 \item otra de las decisiones importantes que debemos hacer a la hora de trabajar con colecciones es el tipo
 de estructura con la que vamos a trabajar. Esta decisión depende de varios factores: si se aceptan elementos
 duplicados, si queremos mantener un orden de los elementos, si ese orden lo queremos definir explícitamente,
 cuán fácil queremos hacer la búsqueda de un elemento particular, si la cantidad de elementos es fija o variable,
 etc.
\end{itemize}


\section{Bibliografía}

\begin{itemize}
 \item Andrew Black, Stéphane Ducasse, Oscar Nierstrasz, Damien Pollet, \textit{Squeak by Example}, 
 Square Bracket Associates, en especial capítulos 9 - Collections y 10 - Streams
 \item Victoria Pocladova, Carlos Lombardi, Leonardo Volinier y Jorge Silva, \textit{Colecciones en Smalltalk},
 del sitio web \\
\begin{minipage}[t]{0.5\textwidth}
     \href{http://pdep.com.ar/material/apuntes}{{\color{blue}http://pdep.com.ar/material/apuntes}}
\end{minipage}
 \item Kent Beck, \textit{Smalltalk Best Practice Patterns}, Prentice-Hall, capítulo 5 - Collections
 \item Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, \textit{Design Patterns, Elements of
 Reusable Object-Oriented Software}, Addison-Wesley, capítulo sobre el patrón Iterator (257)
 \item Adele Goldberg, David Robson, \textit{Smalltalk-80, The Language}, Addison-Wesley, 
 capítulos 9 - Protocol for All Collection Classes y 10 - Hierarchy of the Collection Classes
 \item Wilf Lalonde, \textit{Descubra Smalltalk}, Addison Wesley/Díaz de Santos, capítulo 7 (Objetos contenedores)
 \item Fernando Dodino, \textit{Objetos - Módulo 5} (Intro a Colecciones. Bloques de código. Declaratividad en objetos)
 y \\ \textit{Objetos - Módulo 6}, (Tipos de Colección), del sitio web \\
\begin{minipage}[t]{0.5\textwidth}
     \href{http://http://pdep.com.ar/material/apuntes/clases-sabado-a-la-manana}
     {{\color{blue}http://http://pdep.com.ar/material/apuntes/clases-sabado-a-la-manana}}
\end{minipage} 
\end{itemize}
 
  
\end{document}
