% !TEX encoding = UTF-8 Unicode
\documentclass[a4paper,12pt]{book}

\setlength{\headheight}{1.1\baselineskip}
 
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

\usepackage{geometry}
\usepackage[sc]{mathpazo}

\usepackage{amsmath}

\usepackage[usenames,dvipsnames]{color} 
\usepackage{hyperref}
\usepackage{alltt}

% Para footer con páginas
\usepackage{scrpage2}
\usepackage{lastpage}

% Para insertar imágenes y ubicarlas
\usepackage{graphicx}
\usepackage{placeins}

% Para insertar código
\usepackage{xcolor}
\usepackage{listings}
\input{../common/macros}  

\ifoot[]{}
\cfoot{\thepage\ of \pageref{LastPage} }
\ofoot[]

\pagestyle{scrplain}

\vspace{0.1in}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\begin{document}

\chapter{Herencia}
Las colecciones son un concepto importante y poderoso al diseñar con objetos. En este capítulo veremos cómo
se modela el conocimiento de un conjunto de referencias de un objeto y su utilización para resolver un problema
concreto.

\tableofcontents

\section{Introducción}

En capítulos precedentes introdujimos el concepto de \emph{clase}: un molde que define la estructura y comportamiento de los objetos creados a partir de ella. Las clases nos ofrecen tanto un marco conceptual como ventajas prácticas: por un lado nos permiten agrupar objetos similares bajo una misma abstracción, dándoles un nombre común (el nombre de la clase), y por otro lado nos permiten definir una única vez el comportamiento de un objeto y reutilizarlo en varios objetos. Por ejemplo, podemos podemos definir una clase \ct{Heroe} que permita desplazar nuestros héroes entre distintos casilleros de la siguiente manera:

\begin{code}
Object subclass: #Heroe
	instanceVariableNames: ''.
	
Heroe >> desplazarseA: unCasillero
    unCasillero recibirHeroe: self.
\end{code}

Consideremos ahora que queremos introducir distintas \emph{especies} de héroes: arqueros y guerreros. Arqueros y guerreros son héroes que van a participar en distintas batallas épicas y por lo tanto deben poder hacer daño. Además, tanto arqueros como guerreros poseen, obviamente, distintas características de combate que podemos representar en código utilizando distintas clases \ct{Arquero} y \ct{Guerrero}:

\begin{code}
Object subclass: #Arquero
	instanceVariableNames: 'flecha'.
	
Arquero >> danoCausado
    ^ flecha poder + self modificadorDestreza.
    
Object subclass: #Guerrero
	instanceVariableNames: 'arma'.
	
Guerrero >> danoCausado
    ^ arma poder + self modificadorFuerza.
\end{code}

Usar distintas clases para guerreros y arqueros nos permite definir distintos comportamientos para cada uno de ellos. Sin embargo, nuestros nuevos héroes ya no comparten el comportamiento que definimos anteriormente en nuestra clase \ct{Heroe}. Para solucionar este problema, este capítulo introduce el concepto de \textbf{herencia}. La herencia es una relación entre clases que permite definir super-clasificaciones y sub-clasificaciones de objetos, generar distintos niveles de abstracción y compartir comportamiento entre distintas clases. Estos distintos niveles de abstracción llevan a la aparición de clases concretas y clases abstractas. Finalmente este capítulo discute distintos criterios de aplicación de herencia.

\section{Clasificando Objetos con Herencia}

\gp{diagrama de venn}

\section{Herencia}

\section{Method Lookup}

\section{\ct{self} vs \ct{super}}


method lookup revisited 2
self vs super

\section{Clases concretas vs clases abstractas}

Al generar superclases sigo perdiendo información, gano en generalidad. Un Ave quizás no
tenga sentido instanciarlo. Si en mi aplicación no voy a instanciar aves (porque representan un
concepto demasiado general) entonces la clase es abstracta.
Diferencia entre Smalltalk y Java:

1) En Smalltalk no tiene sentido crear un ave, aunque podría. La clase es abstracta
cuando no tengo intención de crear instancias de esa clase (porque no tiene sentido).

2) En Java no puedo crear un ave aunque quisiera. La clase es abstracta y el compilador
me impide generar instancias de esa clase. Son dos filosofías distintas.
public abstract class Ave forma parte de la definición misma de clase

ejemplo de herencia con superclase abstracta
ejemplo de herencia con superclase concreta

\section{Criterios para utilizar herencia}
\subsection{Usar Objetos vs Clases}
\subsection{Especializar vs Generalizar}

Otra forma de ver la herencia: subclasificamos un concepto conocido, lo refinamos. Si mi hija
no conoce lo que es una tonina, yo le puedo explicar: “Y… es como un delfín pero negro” (una
especie de … pero que …; mostrando tanto en lo que se parece como en lo que se diferencia). 

Tenemos conceptos conocidos: golondrina, colibrí, torcaza, paloma, gorrión. Muchos de estos
pájaros tendrán cosas en común pero se diferencian en algo…
Una vez que reconocí varios objetos, puedo abstraer una clase. Pierdo información, porque lo
que obtengo es más general (una golondrina genérica, en lugar de esta o aquella golondrina,
que era de color azul y yo llamaba pepita).
Ahora vamos a trabajar con otro tipo de abstracción: tengo varias clases (conceptos) y llego a
una jerarquía de clases de la más general a las más particulares: 

Otra forma de ver la herencia: subclasificamos un concepto conocido, lo refinamos. Si mi hija
no conoce lo que es una tonina, yo le puedo explicar: “Y… es como un delfín pero negro” (una
especie de … pero que …; mostrando tanto en lo que se parece como en lo que se diferencia).

\subsection{subclase vs subtipo}
\subsection{Herencia vs composición}

  
\end{document}
